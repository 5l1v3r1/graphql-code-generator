(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{177:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return c}));var r=n(1),a=n(10),o=(n(0),n(240)),i={id:"typescript-resolvers",title:"TypeScript Resolvers"},l={id:"plugins/typescript-resolvers",title:"TypeScript Resolvers",description:"This plugin generates types for resolve functions. ",source:"@site/docs/plugins/typescript-resolvers.md",permalink:"/docs/plugins/typescript-resolvers",editUrl:"https://github.com/dotansimha/graphql-code-generator/edit/master/website/docs/plugins/typescript-resolvers.md",sidebar:"sidebar",previous:{title:"TypeScript 1.0 Compatibility",permalink:"/docs/plugins/typescript-compatibility"},next:{title:"TypeScript GraphQL Files Modules",permalink:"/docs/plugins/typescript-graphql-files-modules"}},s=[{value:"Installation",id:"installation",children:[]},{value:"Usage",id:"usage",children:[]},{value:"Configuration",id:"configuration",children:[]},{value:"How It Works",id:"how-it-works",children:[]},{value:"Intergration with Apollo-Server",id:"intergration-with-apollo-server",children:[]},{value:"Plugin Customization",id:"plugin-customization",children:[]},{value:"Mappers - overwrite parents and resolved values",id:"mappers---overwrite-parents-and-resolved-values",children:[]},{value:"Custom Context Type",id:"custom-context-type",children:[]}],p={rightToc:s};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This plugin generates types for resolve functions. "),Object(o.b)("p",null,"You can use this plugin as-is to generate simple resolvers signature based on your GraphQL types, or you can change it's behaviour be providing custom model types (",Object(o.b)("inlineCode",{parentName:"p"},"mappers"),")."),Object(o.b)("h2",{id:"installation"},"Installation"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"$ yarn add -D @graphql-codegen/typescript-resolvers\n")),Object(o.b)("h2",{id:"usage"},"Usage"),Object(o.b)("p",null,"Run ",Object(o.b)("inlineCode",{parentName:"p"},"graphql-codegen")," as usual:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"schema: schema.json\ngenerates:\n  ./src/resolvers-types.ts:\n    plugins:\n      - typescript\n      - typescript-resolvers\n")),Object(o.b)("p",null,"Import the types from the generated file and use in the resolver:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { QueryResolvers } from './resolvers-types';\n\nexport const resolvers: QueryResolvers = {\n  myQuery: (root, args, context) => {},\n};\n")),Object(o.b)("p",null,"This will make the resolver fully typed and compatible with typescript compiler, including the handler's arguments and return value."),Object(o.b)("p",null,"Generated resolvers can be passed directly into ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.npmjs.com/package/graphql-tools"}),"graphql-tools")," ",Object(o.b)("inlineCode",{parentName:"p"},"makeExecutableSchema")," function."),Object(o.b)("h2",{id:"configuration"},"Configuration"),Object(o.b)("p",null,"{@import: ../docs/generated-config/base-visitor.md}\n{@import: ../docs/generated-config/base-resolvers-visitor.md}\n{@import: ../docs/generated-config/typescript-resolvers.md}"),Object(o.b)("h2",{id:"how-it-works"},"How It Works"),Object(o.b)("p",null,"This plugin generated TypeScript resolvers signature based on your GraphQL schema.  It creates a default TypeScript resolvers signature, according to your GraphQL schema:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"type Query {\n  allUsers: [User]\n  userById(id: Int!): User\n}\n\ntype User {\n  id: Int!\n  name: String!\n  email: String!\n}\n")),Object(o.b)("p",null,"Given the schema above, the output should be the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"export interface QueryResolvers<ContextType = any, ParentType = Query> {\n  allUsers?: Resolver<Array<Maybe<User>>, ParentType, ContextType>;\n  userById?: Resolver<Maybe<User>, ParentType, ContextType, QueryUserByIdArgs>;\n}\n\nexport interface UserResolvers<ContextType = any, ParentType = User> {\n  id?: Resolver<number, ParentType, ContextType>;\n  name?: Resolver<string, ParentType, ContextType>;\n  email?: Resolver<string, ParentType, ContextType>;\n}\n\nexport type Resolvers<ContextType = any> = {\n  Query?: QueryResolvers<ContextType>;\n  User?: UserResolvers<ContextType>;\n};\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You'll get a ",Object(o.b)("inlineCode",{parentName:"p"},"TypeResolver")," per each type/union/interface, and also a root ",Object(o.b)("inlineCode",{parentName:"p"},"Resolvers")," type that points to all resolvers.")),Object(o.b)("p",null,"Let's talk what you get by default in each resolver function signature:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"an object that its parent resolved, we call it Parent."),Object(o.b)("li",{parentName:"ul"},"a value that resolver returns"),Object(o.b)("li",{parentName:"ul"},"arguments"),Object(o.b)("li",{parentName:"ul"},"a context")),Object(o.b)("p",null,"By default, the context is just an empty object ",Object(o.b)("inlineCode",{parentName:"p"},"{}"),"."),Object(o.b)("p",null,"Arguments are generated based on schema, so you don't have to think about them.\nTypes of a parent and a returned value are pretty interesting. Given the example schema:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"type Query {\n  allUsers: [User]\n  userById(id: Int!): User\n}\n\ntype Profile {\n  bio: String\n}\n\ntype User {\n  id: Int!\n  name: String!\n  email: String!\n  profile: Profile\n}\n")),Object(o.b)("p",null,"By default:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"all fields in ",Object(o.b)("inlineCode",{parentName:"li"},"Profile")," expects to get a ",Object(o.b)("inlineCode",{parentName:"li"},"Profile")," typed object as a parent"),Object(o.b)("li",{parentName:"ul"},"fields in ",Object(o.b)("inlineCode",{parentName:"li"},"User")," receives a ",Object(o.b)("inlineCode",{parentName:"li"},"User")," as a parent"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"User.profile")," returns ",Object(o.b)("inlineCode",{parentName:"li"},"Profile")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Query.userById")," expects to returns ",Object(o.b)("inlineCode",{parentName:"li"},"User")," typed object")),Object(o.b)("p",null,"This behavior might fit well with how your resolvers look like but in some cases you want to tweak it a bit."),Object(o.b)("h2",{id:"intergration-with-apollo-server"},"Intergration with Apollo-Server"),Object(o.b)("p",null,"If you are using Apollo Server with TypeScript, note that you need to set ",Object(o.b)("inlineCode",{parentName:"p"},"useIndexSignature: true")," in your config, in order to add a compatible index signature (",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/dotansimha/graphql-code-generator/issues/1133#issuecomment-456812621"}),"more info"),")."),Object(o.b)("p",null,"If you wish to have an easy start, and have the ability to use resolvers chaining without models types, you can also add to your config ",Object(o.b)("inlineCode",{parentName:"p"},"defaultMapper: Partial<{T}>"),". This will allow you to return partial typse in your resolvers."),Object(o.b)("h2",{id:"plugin-customization"},"Plugin Customization"),Object(o.b)("p",null,"The generated resolver's signature type can be overridden or modified by taking advantage of the generic deceleration feature."),Object(o.b)("h2",{id:"mappers---overwrite-parents-and-resolved-values"},"Mappers - overwrite parents and resolved values"),Object(o.b)("p",null,"Remember the example we showed you, when the GraphQL type ",Object(o.b)("inlineCode",{parentName:"p"},"User")," expects to be resolved by ",Object(o.b)("inlineCode",{parentName:"p"},"User")," typed object? What if an object returned by ",Object(o.b)("inlineCode",{parentName:"p"},"Query.userById")," has ",Object(o.b)("inlineCode",{parentName:"p"},"_id")," property instead of ",Object(o.b)("inlineCode",{parentName:"p"},"id"),". It breaks the default behavior. Thats' why we implemented mappers."),Object(o.b)("p",null,"The idea behind Mappers is to map a TypeScript model interface to a GraphQL Type so you overwrite that default generated code, because always there is a difference between what GraphQL exposes and how you data is structured internally."),Object(o.b)("p",null,"The default implementation of ",Object(o.b)("inlineCode",{parentName:"p"},"typescript-resolvers")," plugin is using the GraphQL base types generated by ",Object(o.b)("inlineCode",{parentName:"p"},"typeascript")," plugin, and expect this as return value. We can't guess how your data is structured, and we don't attempt to, we just provide default types based on your schema."),Object(o.b)("p",null,"You should use ",Object(o.b)("inlineCode",{parentName:"p"},"mappers")," to map the GraphQL types and your actual model types in order to tell the codegen to use your types instead of the default ones."),Object(o.b)("p",null,"So let's define one. This is what ",Object(o.b)("inlineCode",{parentName:"p"},"Query.userById")," passes on to the ",Object(o.b)("inlineCode",{parentName:"p"},"User")," type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"// src/types.ts\n\nexport interface UserModel {\n  _id: string;\n  name: string;\n  email: string;\n  profile: {\n    bio: text;\n  };\n}\n")),Object(o.b)("p",null,"This is how to map that interface with the according type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"# ...\ngenerates:\n  path/to/file.ts:\n    config:\n      mappers:\n        User: ./types#UserModel\n    plugins:\n      - typescript-resolvers\n")),Object(o.b)("p",null,"Inside of ",Object(o.b)("inlineCode",{parentName:"p"},"config.mappers")," we wired the ",Object(o.b)("inlineCode",{parentName:"p"},"User")," with ",Object(o.b)("inlineCode",{parentName:"p"},"UserModel")," from ",Object(o.b)("inlineCode",{parentName:"p"},"./types.ts"),". You can also define the interface inside of the config file or even use ",Object(o.b)("inlineCode",{parentName:"p"},"any")," and other primitive types."),Object(o.b)("p",null,"By creating a mapper for ",Object(o.b)("inlineCode",{parentName:"p"},"User:UserModel")," you basically telling the codegen that ",Object(o.b)("inlineCode",{parentName:"p"},"UserModel")," is the actual value that we expect to use, instead of the default structure, and then your implementation of resolver could be type-checked and use your own types. (a complete explaintation could be found ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/dotansimha/graphql-code-generator/issues/1219#issuecomment-549244957"}),"here"),")"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"By typing ",Object(o.b)("inlineCode",{parentName:"p"},"./types#UserModel")," we tell codegen to create an import statement that includes ",Object(o.b)("inlineCode",{parentName:"p"},"UserModel")," and gets it from ",Object(o.b)("inlineCode",{parentName:"p"},"./types")," module\nRemember! The path have to be relative to the generated file.")),Object(o.b)("p",null,"Every other, not mapped type follows the default convention, so in order to overwrite it you can use the ",Object(o.b)("inlineCode",{parentName:"p"},"defaultMapper")," option:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"# ...\ngenerates:\n  path/to/file.ts:\n    config:\n      defaultMapper: any\n      mappers:\n        User: ./types#UserModel\n    plugins:\n      - typescript-resolvers\n")),Object(o.b)("p",null,"Given the above config, every other type then ",Object(o.b)("inlineCode",{parentName:"p"},"User")," will have ",Object(o.b)("inlineCode",{parentName:"p"},"any")," as its parent and resolved value. We don't recommend to do it but it might be very helpful when you try to slowly map all types."),Object(o.b)("h2",{id:"custom-context-type"},"Custom Context Type"),Object(o.b)("p",null,"If you wish to use a custom type for your GraphQL context, yet you don't want to specify it each and every time you declare your resolvers, you can do it in the config file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"# ...\ngenerates:\n  path/to/file.ts:\n    config:\n      contextType: ./context#MyContext\n    plugins:\n      - typescript-resolvers\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"export interface MyContext {\n  authToken: string;\n}\n")),Object(o.b)("p",null,"The config above will make every resolver to have ",Object(o.b)("inlineCode",{parentName:"p"},"MyContext")," as a context type."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { QueryResolvers } from './resolvers-types';\n\nexport const resolvers: QueryResolvers = {\n  myQuery: (root, args, context) => {\n    const { authToken } = context;\n    // ...\n  },\n};\n")),Object(o.b)("p",null,"Field resolvers will be modfied as well."))}c.isMDXComponent=!0},240:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return y}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=a.a.createContext({}),c=function(e){var t=a.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},b=function(e){var t=c(e.components);return a.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),b=c(n),d=r,y=b["".concat(i,".").concat(d)]||b[d]||u[d]||o;return n?a.a.createElement(y,l({ref:t},p,{components:n})):a.a.createElement(y,l({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);